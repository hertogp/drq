#!/usr/bin/env python

# author : git.hertogp@gmail.com
# license: see file LICENSE or <http://unlicense.org>

'''
Dns ReQuest checker

usage: drq -a db.add -d db.ref [options]

 with at least one of:
 -a db.add  zone file with records to add
 -d db.del  zone file with records to delete

 options include:

 -r db.ref  zone file against which additions/removals are checked
 -q         query DNS to check add/del records (even if no -r db.ref was given)
 -c <num>   use <num> concurrent dns queries [default is 5]
 -n ns_ip   name server ip to be queried instead of default resolver
 -t         use tcp/53 queries instead of udp/53 queries
 -p         include/create PTR-records for A-records to add/del
 -s         use strict checking
 -D         print debugging info
 -v <num>   verbosity level
 -h         print this message and exit


 -a db.add
    drq checks whether these records (zone-file format) exist or not and reports
    them as ADD'd or NOT ADD'd (ie still to add).

 -d db.del
    drq checks whether these records (zone-file format) exist or not and reports
    them as DEL'd or NOT DEL'd (ie still to be deleted).

 -r db.ref
    drq uses these records as an off-line representation of DNS records
    (zone-file format) against which to check add/delete requests.  If not
    given, -q is implied.

 -q
    Query DNS to see of whether records proposed for addition (-a db.add)
    still need to be added (or not) and/or whether records proposed for deletion
    (-d db.del) still need to be removed (or not). If no -r db.ref is used, this
    option is implied (i.e. dns will be queried anyway).

 -c <num>
    Maximum number of concurrent sessions to use when sending out DNS queries.
    Defaults to 5.  You might want to lower this if using an ssh tunnel to
    direct tcp-based queries via a stepping stone onto a dns server.

 -n ns_ip
    Donot use the system's default resolver, use the nameserver at <ns_ip>
    instead.  Useful if your local system's idea of how to resolve names does
    not suit your purpose.

 -t
    Use tcp/53 to query nameservers instead of udp/53.  Mainly useful for
    proxying DNS queries via a remote jumphost using e.g. proxychains:

        $ ssh -fND 22222 your_acct@jumphost
        $ proxychains drq -r db.ref -a db.add -n <remote_ns_ip> -t

    -> 22222/tcp is the local port where proxychains expects its socks server
    (searches ./proxychains.conf, $HOME/.proxychains/proxychains.conf and
    finally /etc/proxychains.conf for its configuration).

    If you get 'connection refused' your SSH tunnel is probably not up &
    running.  Connection timeout's usually mean the -t was not given which means
    drq is using udp/53 which doesn't get proxied.

 -o file.csv
    Write results to file.csv (in csv format)

 -p
    Automatically add PTR-records for each A-record to be checked.  Sometimes
    local conventions call for such a 1-on-1 relationship.  Using -p you only
    need to provide the A-records.

 -s
    Strict checking: if a name maps to more than one address (and vice versa for
    reverse mappings) report those as 'RESIDUAL'.  Useful for situations where
    there should be only 1 mapping per name/address combination.

 -D
    Print some extra (debugging) info to stderr.

 -v <num>
    Controls the level of informational messages printed to stdout.  Defaults to
    0, which doesn't clutter the reports too much.
'''

# Disable some pylint warnings
# pylint: disable=C0321

# import argparse  # have to run in 2.3.4
import getopt
import threading
import dns.zone
import dns.reversename
import dns.exception
import dns.resolver
import dns.rcode
import dns.rdtypes.ANY.PTR
import dns.message
import dns.query
import sys
import datetime
import socket
import exceptions

from multiprocessing.dummy import Pool as ThreadPool
from multiprocessing import Pool

# pylint: disable=too-many-instance-attributes, too-few-public-methods,
# pylint: disable=invalid-name
class Container(object):
    '''ARGS container'''
    def __init__(self):
        'set up default argument values'
        self.r = None  # zref file handle
        self.a = None  # zadd file handle
        self.d = None  # zdel file handle
        self.v = 0     # verbosity level
        self.n = dns.resolver.Resolver().nameservers[0] # name server ip
        self.t = False # use tcp (t=true) else udp (t=false) for dns queries
        self.s = False # strict checking
        self.o = None  # output file for csv formatted results
        self.p = False # check reverse mappings
        self.q = False # query network
        self.c = 5     # max 5 concurrent queries
        self.D = False # print Debug info

# GLOBS
BAR1 = '-'*70 + '\n'
BAR2 = '='*70 + '\n'
ARGS = Container()

def usage():
    '''print usage and exit'''
    print __doc__
    sys.exit(0)

def dbg(*words):
    'print dbg information to stderr'
    if not ARGS.D: return
    print >> sys.stderr, '[drq:dbg]:' + ' '.join(str(w) for w in words)
    sys.stderr.flush()

def log(level=0, *words):
    'possibly print log information to stdout'
    if level > ARGS.v: return
    print >> sys.stdout, ' '.join(str(w) for w in words)
    sys.stdout.flush()

def log_soa_rdta(level, name, rdta):
    'log soa record for name(server) in one line to console'
    if rdta is None:
        log(level, name, 'no (r)data available')
        return

    log(level, rdta.mname, str(rdta.rname).replace('.', '@', 1),
        'serial %s,' % rdta.serial,
        'refresh %d(%s),' % (rdta.refresh, sec2str(rdta.refresh)),
        'retry %d(%s),' % (rdta.retry, sec2str(rdta.retry)),
        'expire %d(%s),' % (rdta.expire, sec2str(rdta.expire)),
        'min %d(%s)' % (rdta.minimum, sec2str(rdta.minimum)),
        name)

def rep_rr(level, zone, prefix='', title=None):
    'report RR-s of zone to console with a prefix'
    if level > ARGS.v: return
    if title is not None: log(level, BAR1, title)
    if len(zone.nodes) == 0: return
    for name, ttl, rdta in zone.iterate_rdatas(dns.rdatatype.ANY):
        line = '%-30s %6d %s %-5s %s' % (name,
                                        ttl,
                                        dns.rdataclass.to_text(rdta.rdclass),
                                        dns.rdatatype.to_text(rdta.rdtype),
                                        rdta)
        if len(prefix) == 0: log(level, line)
        else: log(level, prefix, line)

def csv_rr(ofh, zone, req_type, req_status):
    'write request results to csv file'
    cleanup = False
    if zone is None: return
    if type(ofh) == type((str, unicode)):
        ofh = open(ofh, 'w')
        cleanup = True
    if len(zone.nodes) == 0: return
    print >> ofh, ';'.join('name type data request status'.split())
    for name, _, rdta in zone.iterate_rdatas(dns.rdatatype.ANY):
        if rdta.rdtype == dns.rdatatype.SOA: continue
        line = ';'.join([str(name),
                         dns.rdatatype.to_text(rdta.rdtype),
                         str(rdta),
                         req_type,
                         req_status])
        print >> ofh, line
    if cleanup: ofh.close()




def sec2str(seconds):
    'turn seconds into readable string .d(ays).h(rs).m(in).s(ec),'
    rv = []
    seconds = int(seconds)
    days = seconds / 84600
    if days: rv.append('%dd' % days)
    seconds %= 84600
    hrs = seconds / 3600
    if hrs: rv.append('%dh' % hrs)
    seconds %= 3600
    min_ = seconds / 60
    if min_: rv.append('%dm' % min_)
    seconds %= 60
    if seconds: rv.append(',%ds' % seconds)
    return ','.join(rv)


def do_opts(argv):
    'options and argument processing'
    # we use getopt cause this needs to run in 2.3.4+
    # pylint: disable=too-many-branches
    # pylint: disable=too-many-instance-attributes, too-few-public-methods
    try:
        options, positionals = getopt.gnu_getopt(argv, 'r:a:d:v:n:hsto:pqD')
    except getopt.GetoptError, e:
        print 'Error:', str(e)
        sys.exit(2)
    opts = Container()
    for opt, arg in options:
        if opt == '-r': opts.r = arg
        elif opt == '-h': usage()
        elif opt == '-a': opts.a = arg
        elif opt == '-d': opts.d = arg
        elif opt == '-v': opts.v = int(arg)
        elif opt == '-n': opts.n = arg
        elif opt == '-s': opts.s = True
        elif opt == '-o': opts.o = arg
        elif opt == '-p': opts.p = True
        elif opt == '-q': opts.q = True
        elif opt == '-c': opts.c = int(arg)
        elif opt == '-t': opts.t = True
        elif opt == '-D': opts.D = True
        else: assert False, 'unhandled option'

    if len(positionals) > 0: assert False, 'No positionals allowed'
    return opts

def num_rrs(zone):
    'return number of RR-s in the zone'
    if zone is None: return 0
    if zone.nodes is None: return 0
    if len(zone.nodes) == 0: return 0
    return sum(len(rds) for node in zone.nodes.values() for rds in node)

def get_soas(*zones):
    'return list of soa rr-s for all (sub)zones in the list of zones'
    # zoas[zone] -> [(name, ip, soa-rdta), ..]
    # - soa-rdata may be None is the name server did not respond
    zoas = {}
    # loop through all DNS names in the zones & find the zone they're in.
    for name in set().union(*[z.keys() for z in zones if z is not None]):
        # SOA and NS rr-s have zone itself as name.
        if name in zoas or name.parent() in zoas: continue
        # FIXME: dns.resolver.zone_for_name should use the -n <ip> for resolving
        rslvr = dns.resolver.Resolver(filename='', configure=False)
        rslvr.nameservers = [ARGS.n]
        zone_name = dns.resolver.zone_for_name(name, tcp=True, resolver=rslvr)
        dbg('get_soas@%r: find zone: found zone:%r' % (ARGS.n, zone_name))
        if zone_name in zoas: continue
        dbg('get_soas: find zone: is a new zone', zone_name)

        # get NS list for each (new) zone_name
        nameservers = []
        soas = []
        for _, _, rdta, _ in query_rr((zone_name, dns.rdatatype.NS, None)):
            if rdta is None: continue
            nameservers.append(rdta.target)
            ns_ip = query_rr((rdta.target, dns.rdatatype.A, ARGS.n))[0][2].address
            ns_soa = query_rr((zone_name, dns.rdatatype.SOA, ns_ip))[0][2]
            soas.append((rdta.target, ns_ip, ns_soa))

        # add Master to NS-list if not already present
        # (ProRail's pcdy12 master is usually not mentioned in the NS-list)
        # Skip the primaries for soas that could  not be queried on their NS's
        primaries = set([nis[2].mname for nis in soas if nis[2] is not None])
        if len(primaries) > 1:
            dbg('Multiple masters! for zone', zone_name, list(primaries))

        for primary in primaries:
            if primary in nameservers: continue
            dbg('Primary', primary, 'not listed as nameserver:', nameservers)
            ns_ip = query_rr((primary, dns.rdatatype.A, None))[0][2].address
            ns_soa = query_rr((zone_name, dns.rdatatype.SOA, ns_ip))[0][2]
            soas.append((primary, ns_ip, ns_soa))

        zoas[zone_name] = soas

    return zoas

def query_rr(question):
    'Get RRs [(name, ttl, rdta, errmsg),..] for question=(name,rdtype,at_ip)'
    name, rdtype, at_ip = question

    # sanity check name to resolve
    if name is None or len(name) < 1:
        return [(name, 0, None, 'skipping weird name')]

    # fall back to default nameserver if no target ns was given
    if at_ip is None: at_ip = ARGS.n
    errmsg = ''
    try:
        qry = dns.message.make_query(name, rdtype)
        ans = dns.query.tcp(qry, at_ip, timeout=None) if ARGS.t else dns.query.udp(qry, at_ip)
        retval = [(name, rrset.ttl, rdta, '')
                  for rrset in ans.answer for rdta in rrset]
        retval = [elm for elm in retval if len(elm) > 0]
        if len(retval) == 0: retval = [(name, 0, None, 'empty result')]

    except dns.exception.Timeout: errmsg = 'timeout'
    except dns.resolver.NXDOMAIN: errmsg = 'nxdomain'
    except dns.resolver.NoAnswer: errmsg = 'no-answer'
    except dns.resolver.NoNameservers: errmsg = 'no-name-servers'
    except dns.resolver.NoMetaqueries: errmsg = 'no-meta-queries-allowed'
    except socket.error: errmsg = 'socket-error @%s' % at_ip

    # if Exception was caught, return 'no results'-answer w/ clue on error
    if len(errmsg) > 0: retval = [(name, 0, None, errmsg)]

    return retval

# Note:
# - query_rr returns a list of (name, ttl, rdta, errmsg) for a given name.
# - Unfortunately, rdta cannot be pickled (no __get/setstate__ methods) and thus
#   cannot be returned from a child process.
# - Hence we use multithreading instead of multiple processes.
# - The latter would've been better since you can terminate a child-process
#   after x-jobs (it'll respawn) to free up UDP sockets.
# - Theads donot free up UDP sockets (probably needs to time out or something),
#   so when querying all records in a zone, it'll hang if the zone is HUGE.
# - In that case use -t for tcp/53. TCP connections get closed & free up the src
#   socket used for the queries.

def query_zone(zsource):
    'query for RR-s and return them as a zone'
    zone = new_zone()
    if zsource is None: return zone
    if len(zsource.nodes) == 0: return zone

    questions = [[name, rds.rdtype, ARGS.n]
                 for name, rds in zsource.iterate_rdatasets()]
    dbg('qry_zone:', 'resolving %d DNS queries @ %r' % (len(questions), ARGS.n))

    pool = ThreadPool(5)
    answers = pool.map(query_rr, questions)
    dbg('qry_zone:', 'got %d answers' % len(answers))

    for name, ttl, rdta, msg in [rr for answer in answers for rr in answer]:
        if ARGS.D: dbg('qry_zone:', name, 'ttl:', ttl, 'rdta:', str(rdta))
        if rdta is None or len(msg) > 0:
            dbg('qry_zone:', 'got error %s (%s)' % (str(rdta), msg))
            continue
        newrds = zone.get_rdataset(name, rdta.rdtype, create=True)
        newrds.add(rdta)
        newrds.ttl = ttl

    return zone

def trisect_nodes(node1, node2):
    '(relative complement node1, intersection & relative complement node 2)'
    if node1 is None and node2 is None:
        return dns.node.Node(), dns.node.Node(), dns.node.Node()
    if node2 is None: return node1, dns.node.Node(), dns.node.Node()
    if node1 is None: return dns.node.Node(), dns.node.Node(), node2

    # non-None nodes (might still be empty though)
    n1x, n12, n2x = dns.node.Node(), dns.node.Node(), dns.node.Node()

    # return set([(rds.rdclass,rds.rdtype) for node in nodes for rds in node])
    all_types = set([(x.rdclass, x.rdtype) for y in (node1, node2) for x in y])
    for rdclass, rdtype in all_types: # get_rdstypes(node1, node2):
        rds1 = node1.get_rdataset(rdclass, rdtype, create=False)
        rds2 = node2.get_rdataset(rdclass, rdtype, create=False)
        if rds1 is None and rds2 is None:
            continue                         # ignore both empty
        elif rds2 is None:
            n1x.rdatasets.append(rds1)       # uniq to node1
        elif rds1 is None:
            n2x.rdatasets.append(rds2)       # uniq to node2
        else:                                # may overlap
            rds12 = rds1.intersection(rds2)
            if len(rds12) > 0:               # they do overlap
                n12.rdatasets.append(rds12)
                if len(rds1) > len(rds12): n1x.rdatasets.append(rds1 - rds12)
                if len(rds2) > len(rds12): n2x.rdatasets.append(rds2 - rds12)
            else:                            # they dont overlap
                n1x.rdatasets.append(rds1)
                n2x.rdatasets.append(rds2)
    return n1x, n12, n2x

def trisect_zones(zone1, zone2):
    '(relative complement zone1, intersection & relative complement zone2)'
    if zone1 is None and zone2 is None:
        return new_zone(), new_zone(), new_zone()
    if zone1 is None: return new_zone(), new_zone(), zone2
    if zone2 is None: return zone1, new_zone(), new_zone()

    z1x, z12, z2x = new_zone(), new_zone(), new_zone()
    names = set(zone1.nodes.keys() + zone2.nodes.keys())
    for name in names:
        n1x, n12, n2x = trisect_nodes(zone1.get_node(name),
                                      zone2.get_node(name))
        if len(n1x): z1x.nodes[name] = n1x
        if len(n12) > 0: z12.nodes[name] = n12
        if len(n2x) > 0: z2x.nodes[name] = n2x

    return z1x, z12, z2x

def union_zones(*zones):
    'return union of zones'
    uzone = new_zone()
    for name, node in [x for zone in zones for x in zone.items()]:
        unode = uzone.get_node(name, create=True)
        for rds in node:
            urds = unode.get_rdataset(rds.rdclass, rds.rdtype, create=True)
            urds.update(rds)
    return uzone

def new_zone(zfile=None):
    'read zone from file if given, return emtpy zone otherwise'
    if zfile is None: return dns.zone.Zone(dns.name.from_text('.'),
                                           rdclass=dns.rdataclass.IN,
                                           relativize=False)
    # turn name into filehandle, otherwise its already a fhandle
    if type(zfile) == type((str, unicode)): zfile = open(zfile, 'r')

    return dns.zone.from_file(zfile,
                              origin=dns.name.from_text('.'),
                              rdclass=dns.rdataclass.IN,
                              relativize=False,
                              allow_include=True,
                              check_origin=False)

def trim_zone(zone, names):
    'trim a zone down to a particular set of names'
    if zone is None: return new_zone()
    if len(names) == 0: return new_zone()
    for name in zone.nodes.keys():
        if name in names: continue
        for line in zone[name].to_text(name).split('\n'):
            dbg('trim:%s - del RR (%s)' % (name, line))
        zone.delete_node(name)
    return zone

def expand_ptr(zone):
    'for each a-rr, add an ptr-rr to the zone'
    for name, ttl, rdta in [x for x in zone.iterate_rdatas(dns.rdatatype.A)]:
        revname = dns.reversename.from_address(rdta.address)
        rds = zone.find_rdataset(revname, dns.rdatatype.PTR, create=True)
        rds.add(dns.rdtypes.ANY.PTR.PTR(dns.rdataclass.IN,
                                        dns.rdatatype.PTR, name),
                                        ttl)
    return zone  # zone is actually updated 'in-place'


def main():
    'main'
    # NOTEs:
    # o all zones are relative to '.'
    # o so a zref,zadd,zdel zone may contain multiple SOA's (sub)domain-rr's
    # o this script doesn't 'manage' zones, it checks a DNS request
    # o If zref is read from file, it'll be pruned down to zadd+zdel names
    # o Otherwise, zref will be populated by querying for zadd+zdel names


    zadd = new_zone(ARGS.a)        # requested additions from file (if any)
    zdel = new_zone(ARGS.d)        # requested deletions from file (if any)
    zref = new_zone(ARGS.r)        # reference zone from file (if any)
    log(0, BAR2, 'RR-s from file')
    log(0, 'ZADD: %2d RR-s from %r' % (num_rrs(zadd), ARGS.a))
    log(0, 'ZDEL: %2d RR-s from %r' % (num_rrs(zdel), ARGS.d))
    log(0, 'ZREF: %2d RR-s from %r' % (num_rrs(zref), ARGS.r))

    # add ptr-rr's if requested
    if ARGS.p:
        zadd = expand_ptr(zadd)
        zdel = expand_ptr(zdel)
        log(0, BAR1, 'PTR RR-s')
        log(0, 'ZADD: %2d RR-s after PTR-expansion' % num_rrs(zadd))
        log(0, 'ZDEL: %2d RR-s after PTR-expansion' % num_rrs(zdel))

    log(0, BAR1, 'REF trim')
    # zref = trim_zone(zref, set().union(*[z.keys() for z in (zadd, zdel)]))
    # the above don't work on python 2.4.3 ...
    zref = trim_zone(zref, set().union(*[z.keys() for z in (zadd, zdel)]))

    log(0, 'ZREF: %2d RR-s after pruning irrelevant dns names' % num_rrs(zref))

    # record timestamp & soa's on all zones/nameservers involved
    log(0, BAR2, "TIMESTAMP of drq run (for comparison with SOA serials)")
    log(0, '>>', datetime.datetime.now().strftime('%Y-%m-%d, %H:%M:%S'))

    if ARGS.q:
        zoas = get_soas(zref, zadd, zdel)
        log(0, BAR1, 'found %s zones' % str(zoas.keys()))
        for zone, soas in zoas.items():
            log(0, BAR1, 'SOAs for zone %s' % zone)
            for ns_name, ns_ip, ns_soa in soas:
                log_soa_rdta(0, '@%s(%s)' % (ns_name, ns_ip), ns_soa)

    # Query DNS for ZADD/ZDEL names currently missing from ZREF, only if no -r
    # db.ref was given OR we were asked to query the network explicitly via -q
    if not ARGS.r or ARGS.q:
        log(0, BAR2, 'Retrieving ZADD names currently missing from ZREF ..')
        zqry = query_zone(zadd)
        log(0, ' - retrieved %d additional RR-s' % num_rrs(zqry))
        rep_rr(3, zqry, 'q+', 'Found %d live ZADD RR-s' % num_rrs(zqry))
        zref = union_zones(zref, zqry)
        log(0, ' - ZREF now has %2d RR-s after updating' % num_rrs(zref))

        log(0, BAR1, 'Retrieving ZDEL names currently missing from ZREF..')
        zqry = query_zone(zdel)
        log(0, ' - retrieved %d addtional RR-s' % num_rrs(zqry))
        rep_rr(3, zqry, 'q-', 'Found %d live ZDEL RR-s' % num_rrs(zqry))
        zref = union_zones(zref, zqry)
        log(0, ' - ZREF now has %2d RR-s after updating' % num_rrs(zref))

    # if asked, log zone rr's that will be reasoned with
    if ARGS.D:
        log(0, BAR2, 'DEBUG INFO')
        rep_rr(0, zref, '==', 'REF RR-s')
        rep_rr(0, zadd, '++', 'ADD RR-s')
        rep_rr(0, zdel, '--', 'DEL RR-s')

    tri_both = trisect_zones(zadd, zdel) # add-only, add&del, del-only
    tri_adds = trisect_zones(zref, zadd) # ref-only, added, NOT-ADDED
    tri_dels = trisect_zones(zref, zdel) # ref-only, NOT-DELETED, deleted

    # log records that are both in ADDs and DELs (ie inconsistent)
    log(0, BAR2, 'REPORTS')

    rep_rr(0, tri_both[1], '+-',
           'CONFLICTING ADD/DEL RR-s (%d)' % num_rrs(tri_both[1]))

    # strict checking: log RR-s with a with unexpected name/value mapping
    if ARGS.s:
        zsuspect = trisect_zones(tri_adds[0], tri_dels[0])[1]
        rep_rr(0, zsuspect, '<>', 'SURPLUS RR-s (%d)' % num_rrs(zsuspect))

    # log results found for ZADD request(s)
    rep_rr(0, tri_adds[1], '+!',
           'ADD\'d RR-s (%d/%d)' % (num_rrs(tri_adds[1]), num_rrs(zadd)))

    rep_rr(0, tri_adds[2], '+?',
           'NOT ADD\'d RR-s (%d/%d)' % (num_rrs(tri_adds[2]), num_rrs(zadd)))

    # log results found for ZDEL request(s)
    rep_rr(0, tri_dels[2], '-!',
           'DEL\'d RR-s (%d/%d)' % (num_rrs(tri_dels[2]), num_rrs(zdel)))

    rep_rr(0, tri_dels[1], '-?',
           'NOT DEL\'d RR-s (%d/%d)' % (num_rrs(tri_dels[1]), num_rrs(zdel)))

    # write results to csv file if ARGS.o is not None and writeable
    if not ARGS.o is None:
        ofh = open(ARGS.o, 'w')
        csv_rr(ofh, tri_adds[1], 'add', 'ok')
        csv_rr(ofh, tri_adds[2], 'add', 'not ok')
        csv_rr(ofh, tri_dels[2], 'del', 'ok')
        csv_rr(ofh, tri_dels[1], 'del', 'not ok')
        csv_rr(ofh, tri_both[1], 'add/del', 'conflicting')
        if ARGS.s:
            csv_rr(ofh, zsuspect, 'add/del', 'surplus')
        ofh.close()

if __name__ == '__main__':
    ARGS = do_opts(sys.argv[1:])
    main()

